from datetime import datetime


def _format_size(size_bytes):
    '''Format a file size in bytes to a human-readable string.

    Parameters:
        size_bytes: File size in bytes.

    Returns:
        A string like "1.2MB", "200KB", or "512B".
    '''
    if size_bytes >= 1024 * 1024 * 1024:
        return f'{size_bytes / (1024 * 1024 * 1024):.1f}GB'
    elif size_bytes >= 1024 * 1024:
        return f'{size_bytes / (1024 * 1024):.1f}MB'
    elif size_bytes >= 1024:
        return f'{size_bytes / 1024:.1f}KB'
    else:
        return f'{size_bytes}B'


def _format_time(timestamp):
    '''Format a Unix timestamp to YYYY-MM-DD HH:MM.

    Parameters:
        timestamp: A float from os.path.getmtime() or os.stat().st_mtime.

    Returns:
        A formatted date string.
    '''
    return datetime.fromtimestamp(timestamp).strftime('%Y-%m-%d %H:%M')


def generate_report(grouped_results, output_path):
    '''Write a tab-separated duplicate report file.

    The first file in each group is marked KEEP, the rest are marked REMOVE.
    Users can edit the report to change which files to keep or remove before
    executing deletions.

    Parameters:
        grouped_results: Dict from find_all_duplicate_files() keyed by MD5 hash,
                         where each value is a list of file info dicts with keys
                         "path", "file_size", and "last_modified".
        output_path:     Path where the report file will be written.

    Returns:
        None.
    '''
    with open(output_path, 'w', encoding='utf-8') as f:
        first_group = True
        for md5, files in grouped_results.items():
            if not first_group:
                f.write('\n')
            first_group = False

            size_str = _format_size(files[0]['file_size'])
            f.write(f'# [md5: {md5}] [size: {size_str}] [{len(files)} files]\n')

            for i, file_info in enumerate(files):
                action = 'KEEP' if i == 0 else 'REMOVE'
                time_str = _format_time(file_info['last_modified'])
                f.write(f'{action}\t{time_str}\t{file_info["path"]}\n')


def load_report(report_path):
    '''Parse a duplicate report file back into a list of action entries.

    Reads the tab-separated report generated by generate_report() and
    validates that every duplicate group has at least one KEEP entry.

    Parameters:
        report_path: Path to the report file to parse.

    Returns:
        A list of dicts, each with "action" (str) and "path" (str) keys.

    Raises:
        ValueError: If any group contains zero KEEP entries.
    '''
    entries = []
    current_group = []

    with open(report_path, 'r', encoding='utf-8') as f:
        for line in f:
            line = line.rstrip('\n')

            if line.startswith('#'):
                # New group header â€” validate and flush the previous group
                if current_group:
                    _validate_group(current_group)
                    entries.extend(current_group)
                current_group = []
            elif line.strip() == '':
                continue
            else:
                parts = line.split('\t')
                current_group.append({'action': parts[0], 'path': parts[2]})

    # Flush the last group
    if current_group:
        _validate_group(current_group)
        entries.extend(current_group)

    return entries


def _validate_group(group):
    '''Check that a group of report entries has at least one KEEP.

    Parameters:
        group: A list of dicts with "action" and "path" keys.

    Returns:
        None.

    Raises:
        ValueError: If the group has zero KEEP entries.
    '''
    keep_count = sum(1 for entry in group if entry['action'] == 'KEEP')
    if keep_count == 0:
        paths = ', '.join(entry['path'] for entry in group)
        raise ValueError(f'Group has no KEEP entries: {paths}')


def get_files_to_remove(report):
    '''Filter a parsed report to only the file paths marked REMOVE.

    Parameters:
        report: A list of dicts from load_report(), each with "action" and "path".

    Returns:
        A list of file path strings that are marked REMOVE.
    '''
    return [entry['path'] for entry in report if entry['action'] == 'REMOVE']
